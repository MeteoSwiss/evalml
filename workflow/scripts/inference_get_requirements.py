import argparse
import json
import sys
from packaging.version import Version, InvalidVersion


CORE_SUBMODULES = {"models", "training", "graphs"}

SKIP_PACKAGES = {"anemoi-training"}
SKIP_PACKAGES |= set(sys.stdlib_module_names)
SKIP_PACKAGES |= set(sys.builtin_module_names)

BASE_DEPENDENCIES = [
    "anemoi-inference",
    "eccodes==2.39.1",
    "eccodes-cosmo-resources-python",
]


def load_provenance(metadata_path: str) -> dict:
    with open(metadata_path, "r") as f:
        data = json.load(f)
    return data.get("provenance_training", {})


def default_torch_index(torch_version: Version) -> str | None:
    """
    Return the default PyTorch wheel index URL for a given torch version.
    """

    CUDA_BY_TORCH = {
        (2, 10): "cu126",
        (2, 9): "cu126",
        (2, 8): "cu126",
        (2, 7): "cu126",
        (2, 6): "cu124",
        (2, 5): "cu124",
        (2, 4): "cu121",
        (2, 3): "cu121",
    }

    key = (torch_version.major, torch_version.minor)
    cuda_tag = CUDA_BY_TORCH.get(key)

    if not cuda_tag:
        raise ValueError(f"No CUDA version found for torch version {torch_version}")

    return f"https://download.pytorch.org/whl/{cuda_tag}"


def extract_pypi_requirements(
    module_versions: dict[str, str],
    distribution_names: dict[str, str],
) -> dict[str, str]:
    requirements: dict[str, str] = {}

    for module, version_str in module_versions.items():
        if module.startswith("_"):
            continue
        if not version_str or not version_str[0].isdigit():
            continue

        try:
            version = Version(version_str)
        except InvalidVersion:
            continue

        name = module.replace(".", "-")
        name = distribution_names.get(name, name)

        if "anemoi" in name or "torch" in name:
            requirements[name] = version.base_version

    return requirements


def extract_git_requirements(
    git_versions: dict[str, dict],
) -> dict[str, str]:
    requirements: dict[str, str] = {}

    for module, info in git_versions.items():
        if not module.startswith("anemoi."):
            continue

        sha1 = info.get("git", {}).get("sha1")
        if not sha1:
            continue

        submodule = module.split(".")[-1]
        name = module.replace(".", "-")

        if submodule in CORE_SUBMODULES:
            url = (
                "git+https://github.com/ecmwf/anemoi-core"
                f"@{sha1}#subdirectory={submodule}"
            )
        else:
            url = f"git+https://github.com/ecmwf/anemoi-{submodule}@{sha1}"

        requirements[name] = url

    return requirements


def parse_overrides(overrides: list) -> dict[str, str]:
    if not overrides:
        return {}

    result = {}

    # overrides > BASE_DEPENDENCIES
    for item in [*BASE_DEPENDENCIES, *overrides]:
        item = item.strip()
        if not item:
            continue

        if "==" in item:
            name, version = item.split("==", 1)
            result[name.strip()] = version.strip()
        elif any(item.startswith(prefix) for prefix in ("git+", "http://", "https://")):
            name = item.split("/")[-1]
            if "." in name:
                name = name.split(".")[0]
            result[name] = item
        else:
            result[item] = None

    return result


def format_requirements(
    python_version: str | None,
    pypi_requirements: dict[str, str],
    git_requirements: dict[str, str],
    overrides: dict[str, str],
) -> str:
    lines: list[str] = []

    lines.append("# This file is automatically generated from a checkpoint.")
    if python_version:
        lines.append(f"# Python: {python_version}")

    # Detect torch version (if any)
    torch_version = None
    if "torch" in pypi_requirements:
        try:
            torch_version = Version(pypi_requirements["torch"])
        except InvalidVersion:
            pass

    default_index = default_torch_index(torch_version) if torch_version else None

    lines.append("")
    lines.append("# Default index (derived from torch version)")
    lines.append(f"--index-url {default_index}")

    lines.append("")
    lines.append("# Fallback index (PyPI)")
    lines.append("--extra-index-url https://pypi.org/simple")

    # Apply overrides
    for name, value in overrides.items():
        pypi_requirements.pop(name, None)
        git_requirements.pop(name, None)

        if isinstance(value, str) and value.startswith(("http://", "https://", "git+")):
            git_requirements[name] = value
        else:
            pypi_requirements[name] = value

    # Git requirements
    if git_requirements:
        lines.append("")
        lines.append("# Git requirements:")
        lines.append("")

        for name, url in sorted(git_requirements.items()):
            if name in SKIP_PACKAGES:
                continue
            version = pypi_requirements.pop(name, None)
            if version:
                lines.append(f"# {name}=={version}")
            line = url + "  # Extra (not from checkpoint)" if name in overrides else url
            lines.append(line)

    # PyPI requirements
    if pypi_requirements:
        lines.append("")
        lines.append("# PyPI requirements:")
        lines.append("")

        for name, version in sorted(pypi_requirements.items()):
            if name in SKIP_PACKAGES:
                continue
            line = f"{name}=={version}" if version else f"{name}"
            line += "  # Extra (not from checkpoint)" if name in overrides else ""
            lines.append(line)

    return "\n".join(lines)


def main(args: argparse.Namespace) -> None:
    md = load_provenance(args.metadata)

    distribution_names = {
        **md.get("distribution_names", {}),
    }

    pypi_requirements = extract_pypi_requirements(
        md.get("module_versions", {}),
        distribution_names,
    )

    git_requirements = extract_git_requirements(
        md.get("git_versions", {}),
    )

    overrides = parse_overrides(args.overrides)

    output = format_requirements(
        python_version=md.get("python"),
        pypi_requirements=pypi_requirements,
        git_requirements=git_requirements,
        overrides=overrides,
    )

    print(output)


def _parse_overrides(overrides: str) -> list[str]:
    if not overrides:
        return []
    return [item.strip() for item in overrides.split(",") if item.strip()]


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("metadata", help="Path to the metadata JSON file")
    parser.add_argument(
        "--overrides",
        type=_parse_overrides,
        default=None,
        help="Comma-separated list of overrides.",
    )
    args = parser.parse_args()
    main(args)
